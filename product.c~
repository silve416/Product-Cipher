#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define TRANS 1
#define NOTRANS 0
#define PADD 0

#ifndef DEBUG
	#define DEBUG 0
#endif 

#define ENCODE 0
#define DECODE 1

#ifndef MODE
	#define MODE ENCODE
#endif

int transpose_buffer(char *out, char *in, unsigned int dim) {
  
	/* do a columnar encipher/decipher
	 * from in to out
	 * using box of size dim*dim
	 * since it's a square, enciphering and deciphering is the same
	 */
  int i = 0;
  int j = 0;
  int index = 0;
  int data[dim][dim];
  
  //Enter buffer data into array
  for (i=0; i < dim; i++){
    for (j=0; j < dim; j++){
      data[i][j] = in[index];	
      if (DEBUG) printf("IN TRANSPOSE %c\n", in[index]);
      index++;
    }
  }
  //Enter transposed data into write_buf
  index = 0;
  for (j=0; j < dim; j++){
    for (i=0; i < dim; i++){
      out[index] = data[i][j];
      if (DEBUG) printf("IN WRITE %c\n", out[index]);
      index++;
    }
  }
  
  return 0;
}

int dump_buffer(char *buffer, unsigned int bufsize, 
		unsigned int bytes, char *output) {
  
	/* prints a buffer one character at a time to a file using %c
	 * takes in:
	 *  buffer -- pointer to a buffer
	 *  bufsize -- size of 'buffer'
	 *  bytes -- number of bytes from buffer to print
	 *  output -- path to the file to open and output to
	 */
	
	/* open the output or quit on error */
  FILE *OUTPUT;
  if ((OUTPUT = fopen(output, "a+")) == NULL) {
    printf("Problem truncating output file '%s'; errno: %d\n", output, errno);
    return 1;
  }
  /* print 'bytes' bytes from buffer to output file one char at a time */
  for(int i=0; i < bufsize; i++){
    fprintf(OUTPUT, "%c", buffer[i]);
  }
  /* wipe buffer using memset */
  memset(buffer, 0, bufsize);
  
  /* close output file */
  fclose(OUTPUT);
  return bytes;
  
}

int pad_buffer(char *buffer, unsigned int bufsize, unsigned int rbuf_index) {  
  
  /* pad_buffer pads the empty space in a buffer
   *  buffer -- pointer to buffer
   *  bufsize -- size of 'buffer'
   *  rbuf_index -- first "empty" spot in buffer, i.e.,
   *                put the 'X' at rbuf_index and fill the
   *                rest with 'Y' characters.
   */
  
  int padded = 0;
  int i = rbuf_index;
  
  buffer[i] = 'X';
  i++;
  
  while(i < bufsize){
    buffer[i] = 'Y';
    i++;
  }	  
  
	return 1;
	
}

int unpad_buffer(char *buffer, unsigned int bufsize) {
  
  /* unpads a buffer of a given size
   *  buffer -- buffer containing padded data
   *  bufsize -- size of 'buffer'
   */
  
  int unpadded = 0;
  int i = bufsize-1;
  
  if(DEBUG) printf("IN UNPAD FUNC:%c\n", buffer[i]);
  // Read buffer until it reaches X
  while(buffer[i] == 'Y'){
    
    if(DEBUG) printf("BUFF WAS: %c\n", buffer[i]);
    buffer[i] = ' ';
    if(DEBUG) printf("BUFF NOW: %c\n", buffer[i]); 
	    i--;
  }
  
  if(DEBUG) printf("END: %i\n", i);
  
  return i; //Return position of X
  
}

int main(int argc, char *argv[]) {
  
  int i = 0; /* iterator we'll reuse */
  int j = 0;
  
  if (argc < 4) {
    printf("Missing arguments!\n\n");
    printf("Usage: encoder dim infile outfile ['notrans']\n\n");
    printf("Note: outfile will be overwritten.\n");
    printf("Optional '1' as last parameter will disable transposition.\n");
    return 1;
  }
  
  /* give input and output nicer names */
  unsigned int cycles = atoi(argv[1]);/* number of cycles */
  char *key = argv[2];/* key file path */
  char *input = argv[3];/* input file path */
  char *output = argv[4];/* output file path */
  
  /* use 'transmode' to determine if we are just padding or also
   * doing transposition. very helpful for debugging! */

  /*
  unsigned int transmode = TRANS;		
  if (argc > 4 && (atoi(argv[4]) == 1)) {
    printf("Warning: Transposition disabled\n");
    transmode = NOTRANS;
  }
  */

  unsigned int dim = 4;
  unsigned int bufsize = 16;	
  char read_buf[bufsize]; /* buffer for reading and padding */
  char write_buf[bufsize];/* buffer for transposition */
  
  unsigned int data[128];
  unsigned int length = 0;
  unsigned int symbol;//input bytes read into symbol

  FILE *INPUT;
  FILE *OUTPUT;
  
  /* open the key or quit on error */
  if ((INPUT = fopen(key, "r")) == NULL){
    printf("Problem opening key file '%s'; errno: %d\n", key, errno);
    exit(1);
  }

  //Read Key into data array
  while (length < (128) && (symbol = fgetc(INPUT)) != EOF){
    data[length] = (symbol);
    length++;
  }

  fclose(INPUT);
  
  /* open the input or quit on error. */
  if ((INPUT = fopen(input, "r")) == NULL) {
    printf("Problem opening input file '%s'; errno: %d\n", input, errno);
    return 1;
  }  
  
  /* get length of input file */
  unsigned int filesize;		/* length of file in bytes */
  unsigned int bytesleft;		/* counter we reduce on reading */
  struct stat filestats;		/* struct for file stats */
  int err;
  
  if ((err = stat(input, &filestats)) < 0) { //Gets size of input
    printf("error statting file! Error: %d\n", err);
  }
  
  filesize = filestats.st_size;
  bytesleft = filesize;
  
  if (DEBUG) printf("Size of 'input' is: %u bytes\n", filesize); 
  
  /* truncate output file if it exists */ 
  if ((OUTPUT = fopen(output, "w+")) == NULL) {
    printf("Problem truncating output file '%s'; errno: %d\n", output, errno);
    return 1;
  }
  fclose(OUTPUT);
  /* file is reopened and reclosed for in dump_buffer() */  
  
  /* loop through the input file, reading into a buffer and 
   * processing the buffer when 1) the buffer is full or
   * 2) the file has ended (or in the case of decoding, when
   * the last block is being processed.
   */
  
  int rbuf_index = 0;//index into the read buffer
  int pad = 0;//checks if pad has been run
  char cipher;
  unsigned int shift;

  //i for read buff counter, j for key counter
  /* ~Begin Cipher~ */
  if (MODE == ENCODE){
    for(int k=0; k < cycles; k++){
    i = 0;
    j = 0;
    rbuf_index = 0;
  while ((symbol = fgetc(INPUT)) != EOF){

    if(j == length) j=0;

    shift = data[j];
    cipher = (char)((symbol + shift)%256);
    j++;
    
    read_buf[i] = cipher; //Read input into buffer
    i++;
    rbuf_index++;

    //Pad if encoding and last buffer isn't full
    if (rbuf_index == (filesize) && i < bufsize){ 
      if (DEBUG) printf("IN PAD\n");
      pad = pad_buffer(read_buf, bufsize, i); //Set pad to 1 
      i = bufsize;
    }

    // Transpose and dump buffer
    if(i == bufsize){      
      if (DEBUG) printf("TRANSPOSING\n");
      transpose_buffer(write_buf, read_buf, dim);      
      dump_buffer(write_buf, bufsize, rbuf_index, output);
      i=0;
      if (DEBUG){ for(int h=0; h<bufsize; h++) printf("POSITION %c, %d\n", write_buf[h], rbuf_index);}	      
    }
  }  
  if (!pad){ //If the input was not padded, add buffer of padding
    pad_buffer(read_buf, bufsize, i);
    transpose_buffer(write_buf, read_buf, dim);
    dump_buffer(write_buf, bufsize, rbuf_index, output);	    
  }
    }
  }
  
  fclose(INPUT);
  
  return 0;
}
